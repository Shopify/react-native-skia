"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5645],{1184:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>o});var n=s(4041);const i={},r=n.createContext(i);function a(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:t},e.children)}},2581:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"shapes/atlas","title":"Atlas","description":"The Atlas component is used for efficient rendering of multiple instances of the same texture or image. It is especially useful for drawing a very large number of similar objects, like sprites, with varying transformations.","source":"@site/docs/shapes/atlas.md","sourceDirName":"shapes","slug":"/shapes/atlas","permalink":"/react-native-skia/docs/shapes/atlas","draft":false,"unlisted":false,"editUrl":"https://github.com/shopify/react-native-skia/edit/main/docs/docs/shapes/atlas.md","tags":[],"version":"current","frontMatter":{"id":"atlas","title":"Atlas","sidebar_label":"Atlas","slug":"/shapes/atlas"},"sidebar":"tutorialSidebar","previous":{"title":"Ellipses","permalink":"/react-native-skia/docs/shapes/ellipses"},"next":{"title":"Vertices","permalink":"/react-native-skia/docs/shapes/vertices"}}');var i=s(1085),r=s(1184);const a={id:"atlas",title:"Atlas",sidebar_label:"Atlas",slug:"/shapes/atlas"},o=void 0,l={},d=[{value:"RSXform",id:"rsxform",level:2},{value:"Hello World",id:"hello-world",level:2},{value:"Animations",id:"animations",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"The Atlas component is used for efficient rendering of multiple instances of the same texture or image. It is especially useful for drawing a very large number of similar objects, like sprites, with varying transformations."}),"\n",(0,i.jsxs)(t.p,{children:["Its design particularly useful when using with ",(0,i.jsx)(t.a,{href:"#animations",children:"Reanimated"}),"."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"image"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"SkImage or null"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Atlas: image containing the sprites."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"sprites"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"SkRect[]"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"locations of sprites in atlas."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"transforms"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"RSXform[]"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Rotation/scale transforms to be applied for each sprite."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"colors?"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"SkColor[]"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Optional. Color to blend the sprites with."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"blendMode?"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"BlendMode"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Optional. Blend mode used to combine sprites and colors together."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"sampling?"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"Sampling"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["The method used to sample the image. see (",(0,i.jsx)(t.a,{href:"/docs/images#sampling-options",children:"sampling options"}),")."]})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"rsxform",children:"RSXform"}),"\n",(0,i.jsxs)(t.p,{children:["The RSXform object used by the altas API is the compression of the following matrix: ",(0,i.jsx)(t.code,{children:"[fSCos -fSSin fTx, fSSin fSCos fTy, 0, 0, 1]"}),". Below are few transformations that you will find useful:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:"twoslash",children:'import {Skia} from "@shopify/react-native-skia";\n\n// 1. Identity (doesn\'t do anything)\nlet rsxForm = Skia.RSXform(1, 0, 0, 0);\n\n// 2. Scale by 2 and translate by (50, 100)\nrsxForm = Skia.RSXform(2, 0, 50, 100);\n\n// 3. Rotate by PI/4, default pivot point is (0,0), translate by (50, 100)\nconst r = Math.PI/4;\nrsxForm = Skia.RSXform(Math.cos(r), Math.sin(r), 50, 100);\n\n// 4. Scale by 2, rotate by PI/4 with pivot point (25, 25)\nrsxForm = Skia.RSXformFromRadians(2, r, 0, 0, 25, 25);\n\n// 5. translate by (125, 0), rotate by PI/4 with pivot point (125, 25)\nrsxForm = Skia.RSXformFromRadians(1, r, 100, 0, 125, 25);\n'})}),"\n",(0,i.jsx)(t.h2,{id:"hello-world",children:"Hello World"}),"\n",(0,i.jsx)(t.p,{children:"In the example below, we draw in simple rectangle as an image.\nThen we display that rectangle 150 times with a simple transformation applied to each rectangle."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:'import {Skia, drawAsImage, Group, Rect, Canvas, Atlas, rect} from "@shopify/react-native-skia";\n\nconst size = { width: 25, height: 11.25 };\nconst strokeWidth = 2;\nconst imageSize = {\n    width: size.width + strokeWidth,\n    height: size.height + strokeWidth,\n};\nconst image = await drawAsImage(\n    <Group>\n    <Rect\n        rect={rect(strokeWidth / 2, strokeWidth / 2, size.width, size.height)}\n        color="cyan"\n    />\n    <Rect\n        rect={rect(strokeWidth / 2, strokeWidth / 2, size.width, size.height)}\n        color="blue"\n        style="stroke"\n        strokeWidth={strokeWidth}\n    />\n    </Group>,\n    imageSize\n);\n\nexport const Demo = () => {\n  const numberOfBoxes = 150;\n  const pos = { x: 128, y: 128 };\n  const width = 256;\n  const sprites = new Array(numberOfBoxes)\n    .fill(0)\n    .map(() => rect(0, 0, imageSize.width, imageSize.height));\n  const transforms = new Array(numberOfBoxes).fill(0).map((_, i) => {\n    const tx = 5 + ((i * size.width) % width);\n    const ty = 25 + Math.floor(i / (width / size.width)) * size.width;\n    const r = Math.atan2(pos.y - ty, pos.x - tx);\n    return Skia.RSXform(Math.cos(r), Math.sin(r), tx, ty);\n  });\n\n  return (\n    <Canvas style={{ flex: 1 }}>\n      <Atlas image={image} sprites={sprites} transforms={transforms} />\n    </Canvas>\n  );\n};\n'})}),"\n",(0,i.jsx)("img",{src:s(5198).A,width:"256",height:"256"}),"\n",(0,i.jsx)(t.h2,{id:"animations",children:"Animations"}),"\n",(0,i.jsxs)(t.p,{children:["The Atlas component should usually be used with Reanimated.\nFirst, the ",(0,i.jsx)(t.a,{href:"/docs/animations/textures#usetexture",children:"useTexture"})," hook will enable you to create a texture on the UI thread directly without needing to make any copies.\nSecondly, we provide you with hooks such as ",(0,i.jsx)(t.a,{href:"/docs/animations/hooks#userectbuffer",children:(0,i.jsx)(t.code,{children:"useRectBuffer"})})," and ",(0,i.jsx)(t.a,{href:"/docs/animations/hooks#usersxformbuffer",children:(0,i.jsx)(t.code,{children:"useRSXformBuffer"})})," to efficiently animates on the sprites and transformations."]}),"\n",(0,i.jsx)(t.p,{children:"The example below is identical to the one above but the position is an animation value bound to a gesture."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:"twoslash",children:'import {Skia, drawAsImage, Group, Rect, Canvas, Atlas, rect, useTexture, useRSXformBuffer} from "@shopify/react-native-skia";\nimport {useSharedValue, useDerivedValue} from "react-native-reanimated";\nimport {GestureDetector, Gesture} from "react-native-gesture-handler";\n\nconst size = { width: 25, height: 11.25 };\nconst strokeWidth = 2;\nconst textureSize = {\n    width: size.width + strokeWidth,\n    height: size.height + strokeWidth,\n};\n\nexport const Demo = () => {\n  const pos = useSharedValue({ x: 0, y: 0 });\n  const texture = useTexture(\n    <Group>\n      <Rect\n        rect={rect(strokeWidth / 2, strokeWidth / 2, size.width, size.height)}\n        color="cyan"\n      />\n      <Rect\n        rect={rect(strokeWidth / 2, strokeWidth / 2, size.width, size.height)}\n        color="blue"\n        style="stroke"\n        strokeWidth={strokeWidth}\n      />\n    </Group>,\n    textureSize\n  );\n  const gesture = Gesture.Pan().onChange((e) => (pos.value = e));\n  const numberOfBoxes = 150;\n  const width = 256;\n  const sprites = new Array(numberOfBoxes)\n    .fill(0)\n    .map(() => rect(0, 0, textureSize.width, textureSize.height));\n\n  const transforms = useRSXformBuffer(numberOfBoxes, (val, i) => {\n    "worklet";\n    const tx = 5 + ((i * size.width) % width);\n    const ty = 25 + Math.floor(i / (width / size.width)) * size.width;\n    const r = Math.atan2(pos.value.y - ty, pos.value.x - tx);\n    val.set(Math.cos(r), Math.sin(r), tx, ty);\n  });\n\n  return (\n    <GestureDetector gesture={gesture}>\n      <Canvas style={{ flex: 1 }}>\n        <Atlas image={texture} sprites={sprites} transforms={transforms} />\n      </Canvas>\n    </GestureDetector>\n  );\n};\n'})})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},5198:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/hello-world-80a494b280f3d366dc3ef6e8199a9972.png"}}]);