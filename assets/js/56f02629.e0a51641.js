"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[8027],{1184(e,t,n){n.d(t,{R:()=>r,x:()=>d});var i=n(4041);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}},7710(e,t,n){n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"canvas/rendering-modes","title":"Rendering Modes","description":"React Native Skia supports two rendering paradigms: Retained Mode and Immediate Mode. Understanding when to use each is key to building performant graphics applications.","source":"@site/docs/canvas/rendering-modes.md","sourceDirName":"canvas","slug":"/canvas/rendering-modes","permalink":"/react-native-skia/docs/canvas/rendering-modes","draft":false,"unlisted":false,"editUrl":"https://github.com/shopify/react-native-skia/edit/main/apps/docs/docs/canvas/rendering-modes.md","tags":[],"version":"current","frontMatter":{"id":"rendering-modes","title":"Rendering Modes","sidebar_label":"Rendering Modes","slug":"/canvas/rendering-modes"},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/react-native-skia/docs/canvas/overview"},"next":{"title":"Contexts","permalink":"/react-native-skia/docs/canvas/contexts"}}');var s=n(1085),a=n(1184);const r={id:"rendering-modes",title:"Rendering Modes",sidebar_label:"Rendering Modes",slug:"/canvas/rendering-modes"},d=void 0,o={},l=[{value:"Retained Mode (Default)",id:"retained-mode-default",level:2},{value:"Immediate Mode",id:"immediate-mode",level:2},{value:"Choosing the Right Mode",id:"choosing-the-right-mode",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["React Native Skia supports two rendering paradigms: ",(0,s.jsx)(t.strong,{children:"Retained Mode"})," and ",(0,s.jsx)(t.strong,{children:"Immediate Mode"}),". Understanding when to use each is key to building performant graphics applications.\nThe Retained Mode allows for extremely fast animation time with a virtually zero FFI-cost if the drawing list is updated at low frequency. The immediate mode allows for dynamic drawing list but has a higher FFI-cost to pay.\nSince immediate mode uses the same ",(0,s.jsx)(t.code,{children:"<Canvas>"})," element, you can seamlessly combine both rendering modes in a single scene."]}),"\n",(0,s.jsx)(t.h2,{id:"retained-mode-default",children:"Retained Mode (Default)"}),"\n",(0,s.jsx)(t.p,{children:"In retained mode, you declare your scene as a tree of React components. React Native Skia converts this tree into a display list that is extremely efficient to animate with Reanimated.\nThis approach is extremely fast and is best suited for user-interfaces and interactive graphics where the structure doesn't change at animation time."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",metastring:"twoslash",children:'import React, {useEffect} from "react";\nimport { Canvas, Circle, Group } from "@shopify/react-native-skia";\nimport { useSharedValue, withSpring, useDerivedValue } from "react-native-reanimated";\n\nexport const RetainedModeExample = () => {\n  const radius = useSharedValue(50);\n  useEffect(() => {\n    radius.value = withSpring(radius.value === 50 ? 100 : 50);\n  }, []);\n  return (\n    <Canvas style={{ flex: 1 }}>\n      <Group>\n        <Circle cx={128} cy={128} r={radius} color="cyan" />\n      </Group>\n    </Canvas>\n  );\n};\n'})}),"\n",(0,s.jsx)(t.h2,{id:"immediate-mode",children:"Immediate Mode"}),"\n",(0,s.jsx)(t.p,{children:"In immediate mode, you issue drawing commands directly to a canvas on every frame. This gives you complete control over what gets drawn and when, but requires you to manage the drawing logic yourself."}),"\n",(0,s.jsxs)(t.p,{children:["React Native Skia provides immediate mode through the ",(0,s.jsx)(t.a,{href:"/docs/shapes/pictures",children:"Picture API"}),".\nThis mode is extremely well-suited for scenes where the number of drawing commands changes on every animation frame. This is often the case for games, generative art, and particle systems where the scene changes unpredictably on each animation frame."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",metastring:"twoslash",children:'import { Canvas, Picture, Skia } from "@shopify/react-native-skia";\nimport { useDerivedValue, useSharedValue, withRepeat, withTiming } from "react-native-reanimated";\nimport { useEffect } from "react";\n\nconst size = 256;\n\nexport const ImmediateModeExample = () => {\n  const progress = useSharedValue(0);\n  const recorder = Skia.PictureRecorder();\n  const paint = Skia.Paint();\n\n  useEffect(() => {\n    progress.value = withRepeat(withTiming(1, { duration: 2000 }), -1, true);\n  }, [progress]);\n\n  const picture = useDerivedValue(() => {\n    "worklet";\n    const canvas = recorder.beginRecording(Skia.XYWHRect(0, 0, size, size));\n\n    // Variable number of circles based on progress\n    const count = Math.floor(progress.value * 20);\n    for (let i = 0; i < count; i++) {\n      const r = (i + 1) * 6;\n      paint.setColor(Skia.Color(`rgba(0, 122, 255, ${(i + 1) / 20})`));\n      canvas.drawCircle(size / 2, size / 2, r, paint);\n    }\n\n    return recorder.finishRecordingAsPicture();\n  });\n\n  return (\n    <Canvas style={{ flex: 1 }}>\n      <Picture picture={picture} />\n    </Canvas>\n  );\n};\n'})}),"\n",(0,s.jsx)(t.h2,{id:"choosing-the-right-mode",children:"Choosing the Right Mode"}),"\n",(0,s.jsxs)(t.p,{children:["Here is a small list of use-cases and which mode would be best for that scenario. Keep in mind that since these modes use the same ",(0,s.jsx)(t.code,{children:"<Canvas>"})," element they can be nicely composed with each other. For instance a game where the scene is dynamic on every animation frame and some game UI elements are built in Retained Mode."]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Scenario"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Recommended Mode"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Why"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"UI with animated properties"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Retained"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Zero FFI cost during animation"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Data visualization"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Retained"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Structure usually fixed"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Fixed number of sprites/tiles"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Retained"}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["With the ",(0,s.jsx)(t.a,{href:"/docs/shapes/atlas",children:"Atlas API"}),", single draw call"]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Game with dynamic entities"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Immediate"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Entities created/destroyed"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Procedural/generative art"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Immediate"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Dynamic drawing commands"})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);